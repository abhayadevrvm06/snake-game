<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Snake ‚Äî Wraparound (Polished)</title>
<style>
  :root{
    --bg:#071022; --card:#0f1830; --muted:#9fb2ff; --text:#eaf0ff;
    --accent:#7ef36a; --danger:#ff6b6b; --gold:#ffd36b;
  }
  html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial;color:var(--text);background:linear-gradient(180deg,#041126 0%,var(--bg) 100%);display:flex;align-items:center;justify-content:center;padding:18px;}
  .app{width:min(980px,96vw);display:grid;grid-template-columns:1fr 320px;gap:18px;align-items:start}
  .panel{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:14px;padding:14px;border:1px solid rgba(255,255,255,0.04);box-shadow:0 10px 30px rgba(0,0,0,0.45)}
  header{display:flex;align-items:center;justify-content:space-between;gap:10px;margin-bottom:10px}
  h1{font-size:18px;margin:0;display:flex;align-items:center;gap:10px}
  canvas{width:100%;height:auto;display:block;border-radius:10px;background:linear-gradient(180deg,#071126,#071733);image-rendering:pixelated}
  .hud{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .chip{background:rgba(255,255,255,0.03);padding:8px 10px;border-radius:10px;font-weight:700;border:1px solid rgba(255,255,255,0.03)}
  button{cursor:pointer;border:0;padding:8px 10px;border-radius:10px;font-weight:800;background:var(--accent);color:#042018}
  button.ghost{background:transparent;color:var(--text);border:1px solid rgba(255,255,255,0.06)}
  button.secondary{background:#89a3ff;color:#04203a}
  .controls{display:grid;gap:10px}
  .right-panel{display:flex;flex-direction:column;gap:12px;height:100%}
  .section-title{font-size:13px;color:var(--muted);font-weight:700;margin-bottom:6px}
  .small{font-size:13px;color:rgba(255,255,255,0.8)}
  .dpad{display:grid;grid-template-columns:64px 64px 64px;grid-template-rows:64px 64px 64px;gap:8px;justify-content:center;align-items:center}
  .dpad button{width:64px;height:64px;border-radius:10px;border:1px solid rgba(255,255,255,0.06);background:rgba(255,255,255,0.02);font-weight:900}
  label{display:flex;flex-direction:column;gap:6px;font-size:13px}
  input[type="range"]{width:100%}
  footer{margin-top:8px;font-size:12px;color:rgba(255,255,255,0.5)}
  .overlay{position:absolute;inset:0;display:grid;place-items:center;pointer-events:none}
  .overlay .card{pointer-events:auto;background:rgba(4,8,20,0.8);padding:18px;border-radius:12px;border:1px solid rgba(255,255,255,0.05);text-align:center}
  .muted{color:var(--muted)}
  .score-big{font-size:28px;font-weight:900}
  @media (max-width:920px){.app{grid-template-columns:1fr;}.right-panel{order:2}}
</style>
</head>
<body>
<div class="app">
  <div class="panel" style="position:relative;">
    <header>
      <h1>üêç Snake ‚Äî Wraparound (Polished)</h1>
      <div class="hud">
        <div class="chip">Score: <span id="score">0</span></div>
        <div class="chip">Best: <span id="best">0</span></div>
        <button id="pauseBtn" class="ghost">Pause</button>
        <button id="restartBtn" class="secondary">Restart</button>
      </div>
    </header>

    <canvas id="game" width="640" height="640" aria-label="Snake game"></canvas>

    <div id="startOverlay" class="overlay">
      <div class="card">
        <div class="muted">Classic wraparound controls</div>
        <div style="margin-top:8px"><strong class="score-big">Use Arrow Keys</strong></div>
        <div class="small" style="margin-top:8px">Golden apples are rare ‚Äî collect them! Press Play to start.</div>
        <div style="display:flex;gap:8px;justify-content:center;margin-top:12px">
          <button id="playBtn">Play</button>
          <button id="howBtn" class="ghost">How</button>
        </div>
      </div>
    </div>

    <div id="gameOverOverlay" class="overlay" hidden>
      <div class="card">
        <div class="muted">Game Over</div>
        <div style="margin-top:6px" class="score-big" id="finalScore">0</div>
        <div style="display:flex;gap:8px;justify-content:center;margin-top:10px">
          <button id="againBtn">Play Again</button>
          <button id="shareBtn" class="ghost">Copy Score</button>
        </div>
      </div>
    </div>

  </div>

  <aside class="right-panel">
    <div class="panel">
      <div class="section-title">Settings</div>
      <div style="display:flex;gap:8px;align-items:center">
        <label style="flex:1">Initial speed
          <input id="speedRange" type="range" min="4" max="16" step="0.5" value="7">
        </label>
      </div>
      <label>Wraparound
        <select id="wrapSel">
          <option value="1">Through walls (wrap)</option>
          <option value="0">Walls are deadly</option>
        </select>
      </label>
      <label>Mute sounds
        <input id="muteChk" type="checkbox">
      </label>
      <footer>Tip: Use Arrow keys quickly to turn ‚Äî input is buffered.</footer>
    </div>

    <div class="panel">
      <div class="section-title">Touch Controls</div>
      <div class="dpad" id="dpad">
        <div></div><button data-dir="up">‚ñ≤</button><div></div>
        <button data-dir="left">‚óÑ</button><div></div><button data-dir="right">‚ñ∫</button>
        <div></div><button data-dir="down">‚ñº</button><div></div>
      </div>
    </div>

    <div class="panel">
      <div class="section-title">About</div>
      <div class="small">Polished wraparound snake, 2 apple types, particles, and sound. Arrow keys + WASD. Best score stored locally.</div>
    </div>
  </aside>
</div>

<script>
(() => {
  // ===== Config =====
  const GRID = 32;                    // number of cells per row/col
  const CELL = 20;                    // logical cell pixel size (canvas size = GRID*CELL)
  const CANVAS_SIZE = GRID * CELL;    // 640
  const NORMAL_SCORE = 10;
  const GOLD_SCORE = 50;
  const GOLD_PROB = 0.08;             // 8% chance for a golden apple
  const PARTICLE_COUNT = 12;

  // ===== Elements =====
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha: false });
  canvas.width = CANVAS_SIZE; canvas.height = CANVAS_SIZE;
  const scoreEl = document.getElementById('score');
  const bestEl = document.getElementById('best');
  const pauseBtn = document.getElementById('pauseBtn');
  const restartBtn = document.getElementById('restartBtn');
  const playBtn = document.getElementById('playBtn');
  const howBtn = document.getElementById('howBtn');
  const startOverlay = document.getElementById('startOverlay');
  const gameOverOverlay = document.getElementById('gameOverOverlay');
  const finalScoreEl = document.getElementById('finalScore');
  const againBtn = document.getElementById('againBtn');
  const shareBtn = document.getElementById('shareBtn');
  const speedRange = document.getElementById('speedRange');
  const wrapSel = document.getElementById('wrapSel');
  const muteChk = document.getElementById('muteChk');

  document.querySelectorAll('#dpad [data-dir]').forEach(btn => {
    btn.addEventListener('touchstart', (e) => { e.preventDefault(); queueDir(btn.dataset.dir); }, {passive:false});
    btn.addEventListener('click', () => queueDir(btn.dataset.dir));
  });

  // ===== State =====
  let snake = [];
  let prevSnake = [];
  let dir = 'right';
  let queue = [];               // buffered direction inputs
  let apple = null;
  let appleKind = 'normal';     // 'normal' or 'gold'
  let score = 0;
  let best = Number(localStorage.getItem('snake_best') || 0);
  let alive = false;
  let paused = false;
  let wrap = true;
  let speed = Number(speedRange.value); // cells per second
  let accumulator = 0;
  let lastTime = 0;
  let particles = [];
  bestEl.textContent = String(best);

  // Audio setup
  let audioCtx = null;
  function ensureAudio(){ if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
  function beep(freq=440, time=0.06, type='sine', volume=0.08){
    if (muteChk.checked) return;
    try {
      ensureAudio();
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type; o.frequency.value = freq;
      g.gain.value = volume;
      o.connect(g); g.connect(audioCtx.destination);
      o.start();
      g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + time);
      o.stop(audioCtx.currentTime + time + 0.02);
    } catch(e){}
  }

  // ===== Helpers =====
  const copySeg = s => ({x:s.x, y:s.y});
  function rndCell(){ return { x: (Math.random()*GRID)|0, y: (Math.random()*GRID)|0 }; }
  function equal(a,b){ return a.x===b.x && a.y===b.y; }
  function wrapCoord(v){ if(v<0) return GRID-1; if(v>=GRID) return 0; return v; }
  function placeApple(){
    let tries = 0;
    do {
      apple = rndCell();
      tries++;
      if(tries>500) break;
    } while (snake.some(s => equal(s,apple)));
    appleKind = Math.random() < GOLD_PROB ? 'gold' : 'normal';
  }
  function updateScore(delta){
    score += delta;
    scoreEl.textContent = score;
    if(score > best){ best = score; localStorage.setItem('snake_best', String(best)); bestEl.textContent = String(best); }
  }

  // ===== Initialize new game =====
  function newGame(){
    // initialize snake centered, length 4
    const cx = Math.floor(GRID/2), cy = Math.floor(GRID/2);
    snake = [{x:cx,y:cy}];
    for(let i=1;i<4;i++) snake.push({x:cx - i, y:cy});
    prevSnake = snake.map(copySeg);
    dir = 'right'; queue = [];
    score = 0; updateScore(0 - score); // reset
    alive = true; paused = false;
    wrap = wrapSel.value === '1';
    speed = Number(speedRange.value);
    accumulator = 0; lastTime = performance.now();
    placeApple();
    particles = [];
    startOverlay.hidden = true;
    gameOverOverlay.hidden = true;
    beep(880, 0.03, 'square', 0.04); // start beep (audible after gesture)
    requestAnimationFrame(frame);
  }

  // ===== Input =====
  function queueDir(d){
    // convert arrow words to our directions if necessary
    const map = {ArrowUp:'up',ArrowDown:'down',ArrowLeft:'left',ArrowRight:'right',w:'up',a:'left',s:'down',d:'right'};
    if(map[d]) d = map[d];
    const opposite = {left:'right',right:'left',up:'down',down:'up'};
    const current = queue.length ? queue[queue.length-1] : dir;
    if(d && d !== opposite[current]) queue.push(d);
  }
  window.addEventListener('keydown', (e)=>{
    const k = e.key;
    if(k === ' '){ togglePause(); e.preventDefault(); return; }
    if(k === 'r' || k === 'R'){ newGame(); return; }
    if(k === 'p' || k === 'P'){ togglePause(); return; }
    if(k === 'ArrowUp' || k === 'ArrowDown' || k === 'ArrowLeft' || k === 'ArrowRight' || ['w','a','s','d','W','A','S','D'].includes(k)){
      queueDir(k.replace('Arrow',''));
      // resume audio on first user gesture
      if(!audioCtx && !muteChk.checked) { try{ ensureAudio(); audioCtx.resume && audioCtx.resume(); }catch(e){} }
    }
  }, {passive:true});

  // UI Buttons
  pauseBtn.addEventListener('click', togglePause);
  restartBtn.addEventListener('click', ()=>{ startOverlay.hidden = false; gameOverOverlay.hidden = true; });
  playBtn.addEventListener('click', newGame);
  howBtn.addEventListener('click', ()=> alert('Arrow keys or WASD to move. Wraparound means edges teleport you through. Collect golden apples for bonus points.'));
  againBtn.addEventListener('click', newGame);
  shareBtn.addEventListener('click', async ()=>{
    const text = `I scored ${score} on Snake ‚Äî Wraparound!`;
    try {
      await navigator.clipboard.writeText(text + ' ' + location.href);
      alert('Score copied to clipboard!');
    } catch(e) { alert(text); }
  });

  // touch dpad handled earlier
  // speed change
  speedRange.addEventListener('input', ()=> { speed = Number(speedRange.value); });

  // ===== Game loop & logic =====
  function step(){
    // apply queued directions
    if(queue.length) dir = queue.shift();

    // move head
    const head = { ...snake[0] };
    if(dir === 'left') head.x -= 1;
    else if(dir === 'right') head.x += 1;
    else if(dir === 'up') head.y -= 1;
    else if(dir === 'down') head.y += 1;

    // wall handling
    if(wrap){
      head.x = wrapCoord(head.x); head.y = wrapCoord(head.y);
    } else {
      if(head.x < 0 || head.x >= GRID || head.y < 0 || head.y >= GRID){ alive = false; return; }
    }

    // copy previous for interpolation
    prevSnake = snake.map(copySeg);

    // collision with body?
    if(snake.some(seg => equal(seg, head))){
      alive = false;
      return;
    }

    // add head
    snake.unshift(head);

    // apple eaten?
    if(equal(head, apple)){
      if(appleKind === 'normal'){
        updateScore(NORMAL_SCORE);
        beep(1000,0.06,'sine',0.06);
      } else {
        updateScore(GOLD_SCORE);
        beep(1200,0.12,'triangle',0.12);
        // small speed bonus for golden apple
        speed = Math.min(20, speed + 0.25);
      }
      spawnParticles(head.x, head.y, appleKind === 'gold' ? '#ffd36b' : '#ff6b6b');
      placeApple();
      // slight speed increase every eat
      speed = Math.min(20, speed + 0.08);
    } else {
      // normal move: remove tail
      snake.pop();
    }
  }

  function spawnParticles(cx, cy, color){
    const px = cx*CELL + CELL/2, py = cy*CELL + CELL/2;
    for(let i=0;i<PARTICLE_COUNT;i++){
      const a = Math.random()*Math.PI*2;
      const s = 1 + Math.random()*2;
      particles.push({
        x:px, y:py, vx:Math.cos(a)* (1+Math.random()*2)*CELL*0.09, vy:Math.sin(a)*(1+Math.random()*2)*CELL*0.09,
        life:0.5 + Math.random()*0.7, age:0, color, size:2+Math.random()*2
      });
    }
  }

  function updateParticles(dt){
    for(let i=particles.length-1;i>=0;i--){
      const p = particles[i];
      p.age += dt;
      if(p.age >= p.life){ particles.splice(i,1); continue; }
      p.x += p.vx * dt * 60;
      p.y += p.vy * dt * 60;
      p.vy += 0.06 * dt * 60; // gravity-like
    }
  }

  // interpolation draw between prevSnake and snake using progress in [0..1]
  function drawInterpolated(progress){
    // background
    ctx.fillStyle = '#041226'; ctx.fillRect(0,0,canvas.width,canvas.height);

    // subtle grid
    ctx.lineWidth = 1;
    ctx.strokeStyle = 'rgba(255,255,255,0.03)';
    for(let i=0;i<=GRID;i++){
      const p = i * CELL + 0.5;
      ctx.beginPath(); ctx.moveTo(p,0); ctx.lineTo(p,canvas.height); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(0,p); ctx.lineTo(canvas.width,p); ctx.stroke();
    }

    // apple
    const ax = apple.x*CELL, ay = apple.y*CELL;
    if(appleKind === 'gold'){
      // gold apple with shine
      roundRect(ax+3, ay+3, CELL-6, CELL-6, 7, true, false, 'linear-gradient');
      // colored fill
      ctx.fillStyle = '#ffd36b';
      roundRect(ax+4, ay+4, CELL-8, CELL-8, 6, true, false);
    } else {
      ctx.fillStyle = '#ff6b6b';
      roundRect(ax+3, ay+3, CELL-6, CELL-6, 7, true, false);
    }

    // draw particles
    for(const p of particles){
      const t = 1 - (p.age / p.life);
      ctx.globalAlpha = t;
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.ellipse(p.x, p.y, p.size, p.size, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    // draw snake segments (interpolated)
    for(let i=snake.length-1;i>=0;i--){
      const a = prevSnake[i] || prevSnake[prevSnake.length-1] || snake[i]; // fallback
      const b = snake[i];
      const lx = lerp(a.x, b.x, progress) * CELL;
      const ly = lerp(a.y, b.y, progress) * CELL;
      const pad = (i===0?1.5:3);
      const r = (i===0?8:6);
      if(i===0){
        // head glow
        ctx.fillStyle = 'rgba(126,243,106,0.16)';
        ctx.fillRect(lx, ly, CELL, CELL);
        ctx.fillStyle = '#7ef36a';
        roundRect(lx+1.5, ly+1.5, CELL-3, CELL-3, r, true, false);
        // eyes
        ctx.fillStyle = '#041226';
        if(dir === 'left' || dir === 'right'){
          const ex = dir === 'left' ? -3 : 3;
          ctx.fillRect(lx + CELL/2 - 6 + ex, ly + CELL/2 - 5, 3, 3);
          ctx.fillRect(lx + CELL/2 - 0 + ex, ly + CELL/2 - 5, 3, 3);
        } else {
          const ey = dir === 'up' ? -3 : 3;
          ctx.fillRect(lx + CELL/2 - 5, ly + CELL/2 - 6 + ey, 3, 3);
          ctx.fillRect(lx + CELL/2 - 5, ly + CELL/2 - 1 + ey, 3, 3);
        }
      } else {
        ctx.fillStyle = '#5bd251';
        roundRect(lx + pad, ly + pad, CELL - pad*2, CELL - pad*2, r, true, false);
      }
    }
  }

  function lerp(a,b,t){ return a + (b - a) * t; }

  // rounded rect helper (supports linear-gradient placeholder)
  function roundRect(x,y,w,h,r,fill=true,stroke=false, gradientType){
    if(w < 2*r) r = w/2; if(h < 2*r) r = h/2;
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
    if(fill){
      if(gradientType === 'linear-gradient'){
        // small highlight for golden apple
        const g = ctx.createLinearGradient(x,y,x+w,y+h);
        g.addColorStop(0, '#fff7d6'); g.addColorStop(0.2, '#ffd36b'); g.addColorStop(1, '#b88c2a');
        ctx.fillStyle = g;
        ctx.fill();
        return;
      }
      ctx.fill();
    }
    if(stroke) ctx.stroke();
  }

  function frame(now){
    if(!lastTime) lastTime = now;
    const dt = (now - lastTime) / 1000;
    lastTime = now;
    if(!alive) return; // stop loop if dead

    if(!paused){
      accumulator += dt * speed;
      // step for each whole cell worth
      while(accumulator >= 1){
        step();
        accumulator -= 1;
        if(!alive) break;
      }
      // update particles
      updateParticles(dt);
    }

    // draw with interpolation
    let progress = Math.min(1, accumulator); // between last and next step
    drawInterpolated(progress);

    if(alive && !paused) requestAnimationFrame(frame);
    else if(!alive){ // game over
      finalScoreEl.textContent = String(score);
      gameOverOverlay.hidden = false;
      beep(160,0.25,'sine',0.12);
    }
  }

  function togglePause(){
    if(!alive) return;
    paused = !paused;
    pauseBtn.textContent = paused ? 'Resume' : 'Pause';
    if(!paused){ lastTime = performance.now(); requestAnimationFrame(frame); }
  }

  // spawn first overlay visible
  startOverlay.hidden = false;

  // place starting apple if not present
  if(!apple) placeApple();

  // ensure the canvas scales nicely but keeps sharp pixels
  function fitCanvas(){
    const containerW = canvas.parentElement.clientWidth;
    const maxW = containerW - 28;
    const scale = Math.min(1, maxW / CANVAS_SIZE);
    canvas.style.width = (CANVAS_SIZE * scale) + 'px';
  }
  window.addEventListener('resize', fitCanvas);
  fitCanvas();

  // small debounce to resume RAF if page is visible
  document.addEventListener('visibilitychange', () => { if(!document.hidden && alive && !paused){ lastTime = performance.now(); requestAnimationFrame(frame); } });

})();
</script>
</body>
</html>
